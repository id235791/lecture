import
	모듈화를 진행하게 되면 일반적으로 파일이 나뉜다.
	하나의 파일처럼 쓰기 위해서는 import 방법이 필요하다.

	from 파일명 import *

	*는 '모든것'을 의미한다.
	from 뒤에 있는 모듈에서 모든것을 추가하는 코드이다.

변수의 종류
	지역 변수 : 함수 내부에 선언된 변수
		각 함수에 선언된 변수이므로 같은 이름이지만
		함수구역이 다르다면 새롭게 선언이 된다.

	전역 변수 : 함수 외부에 선언된 변수
		함수 내부에서 단순하게 사용시에는 별다른 조건 없이 쓸 수 있다.
		수정은 불가능하다.

global 키워드
	전역변수의 값을 수정할 때 사용하는 키워드
	함수 내부에서 "global 변수명" 을 작성하면
	그 변수는 전역변수를 의미하게 된다.

		전역변수			지역변수
	사용		수정	사용		수정
				  (본인의 지역변수만)
함수 안	가능		불가	가능		가능
		  (global로 가능)
함수 밖	가능		가능	불가		불가

클래스(반)
	반복되는 변수, 메소드들을 통합해서 관리 및 사용하기 위해
	선언 후 사용한다. 공통된 요소들이 모여있는 것
	붕어빵 틀

	1. 주어이다.
		모든 문장 맨 앞에는 클래스가 나오고
		영어는 맨 앞을 항상 대문자로 적는다.
		따라서 클래스는 주어이고 대문자로 시작한다.

		food = "banana"
		Monkey.eat(food)
		[주어] [동사] [목적어]

	2. 타입이다.
		클래스는 추상적인 개념이고 이 클래스 안에는 필드가 존재한다.
		클래스는 추상적이고 실체화되지 않았기 때문에, 그 개념을
		구체화시킨 "객체"가 필요하다. 영어로는 instance variable이라 한다.

		instance 예, 예시이고 추상적인 개념의 한 예시로서 객체가 나오기 때문에
		instance variable이라 부른다.
		(자동차인데 예를 들어 내차)
		[클래스]		[객체]

		추상적인 개념의 클래스를 객체로 만드는 작업을 객체화라고 한다.
		클래스는 그 때 만들어진 객체의 타입이다.

클래스 선언
	class 클래스명:
		필드(변수, 메소드)

클래스 사용
	[객체화]
	객체명 = 클래스명()
	객체.변수
	객체.메소드()

	클래스는 추상적인 개념 자체이고 실체화 되어있지 않기 때문에
	객체를 생성하고 그 객체를 사용한다. 클래스의 필드와 동일하게 생긴
	하나의 필드가 복사되면 그 필드 안에는 여러 값들이 존재할 수 있다.
	하나의 저장공간에는 한개의 값만 담을 수 있기 때문에 객체는 생성된
	필드의 주소값을 가지고 있게 된다.

생성자
	클래스 이름 뒤에 소괄호
	생성자는 함수와 똑같이 사용 가능하지만,
	리턴을 할 수 없기 때문에 함수라고 부르지 않는다.

	클래스를 선언하게 되면 자동으로 생성자가 하나 만들어지고
	코드상에는 나타나지 않는다. 이런 생성자를 기본 생성자라고 하며
	만약 직접 생성자를 선언하게 되면 기본 생성자는 사라지게 된다.

생성자 호출시 일어나는 일
	1. 클래스의 틀과 똑같이 생긴 필드 하나를 메모리에 할당하고
	그 할당된 필드의 주소값을 가지고 온다.

	2. 생성자 선언부 내부에 있는 모든 코드들을 실행한다.

self
	클래스 내부에 선언된 메소드나 생성자는 호출시 접근한 현재 객체를
	매개변수로 함께 받아온다. 클래스 내부에서는 하나의 메소드로
	여러개의 객체를 다루어야 한다. 함께 받아온 self라는 매개변수에 담긴
	객체를 통해서 어떤 객체로 접근했는지를 구별할 수 있게된다.
	메소드 내부에서 self.필드명 으로 접근하면 여러 객체도 하나의 메소드에서
	구별하여 다룰 수 있게된다.
	self는 객체 구별용 변수

클래스 변수와 인스턴스 변수
	클래스 변수 : 클래스 영역에 선언된 변수

	인스턴스 변수 : 객체 안에 선언되어 있는 변수











