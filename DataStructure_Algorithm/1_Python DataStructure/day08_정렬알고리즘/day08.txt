이진트리의 순회
	순회란 트리에 존재하는 모든 데이터를 가져오는 방법을 의미한다.
	구현시 재귀함수를 이용

	전위순회(깊이 우선 탐색 / DFS)
		root -> left -> right
	중위순회(대칭순회)
		left -> root -> right
	후위순회
		left -> right -> root

정렬 알고리즘
	데이터를 순서대로 나열하기 위한 절차적인 과정
	선택, 버블, 삽입, 퀵, ...

알고리즘의 성능 분석
	1. 정확성
		올바른 자료가 입력되었을 때 유한한 시간 내에 올바른 결과를 도출하는가
	2. 명확성
		알고리즘이 이해하기 쉽고 명확하게 작성되었는가
	3. 수행량
		알고리즘의 주요 연산이 얼마나 반복되는가
	4. 메모리 사용량
		문제를 해결하기 위해 얼마나 많은 메모리 공간을 필요로 하는가
	5. 최적성
		알고리즘이 문제 해결 조건에 최적으로 부합하는가

성능 분석 방법
	공간 복잡도
		알고리즘을 프로그램으로 실행하여 완료하는데 필요한 총 저장공간
	시간 복잡도
		알고리즘을 프로그램으로 실행하여 완료하는데까지 소요되는 시간

	빅오 표기법을 사용해서 표기(반복문의 횟수)
		ex)
		스택의 푸쉬,팝 : O(1)

선택 정렬(Selection Sort)
	최소값 또는 최대값을 선택하여 가장 앞에다가 위치하는 작업을
	반복하여 정렬하는 방법
	시간 복잡도 : O(n^2)

	장점 : 구현이 쉽다
	단점 : 다른 정렬에 비해 시간이 오래걸린다.

	기본 로직
		1. 졍렬되지 않은 인덱스의 맨 앞에서부터 이를 포함한
		그 이후의 값들 중에 최소값을 찾아낸다.
			4 [1] 3 5 2
			↑
		2. 최소값을 찾았으면 그 값을 현재 인덱스의 값과 바꾸어준다.
			1 4 3 5 2
			↑
		3. 다음 인덱스로 이동하여 위의 과정을 반복한다.
			1 4 3 5 2
			  ↑

버블 정렬(Bubble Sort)
	인접한 두 수를 비교하여 큰 수를 뒤로 보내는 작업을 반복하여
	정렬하는 방법
	시간 복잡도 : O(n^2)

	장점 : 구현이 쉽고 코드가 직관적이다.
	단점 : 시간이 오래걸린다.

	기본 로직
		1. 맨 앞에서부터 바로 뒤에있는 값과 비교 후
		순서가 거꾸로 되어있다면 둘의 위치를 바꾸어준다.
			4 1 3 5 2	-->	1 4 3 5 2
			↑			↑
		2. 맨 마지막까지 반복해서 바꾸어 주었다면
		가장 마지막에는 최대값이 위치할 것이다.
			1 3 4 2 5
			      ↑
		3. 위의 과정을 반복하여 하되 이전보다 한번 덜 바꾸면
		그 다음 최대값이 바로 앞에 위치할 것이다.

삽입 정렬(Insertion Sort)
	현재 위치에서 그 앞의 인덱스들 중에 자신이 들어갈 위치를
	찾아서 그 위치에 삽입하여 정렬하는 방법
	시간 복잡도 : O(n) ~ O(n^2)

	장점 : 최선의 경우 빠른 효율성을 갖는다.
	단점 : 최악의 경우에는 시간이 오래걸리며 데이터의 상태나 크기에 따라
		성능의 편차가 있다.

	기본 로직
		1. 현재 인덱스(i)의 값을 임시 저장한다.(temp)
		      ↓
			4 1 3 5 2		temp = 1
			  ↑
		2. 그 앞의 값들을 거꾸로 비교하면서 값이 더 큰게 있다면
		바로 뒷자리에 덮어 씌워준다.
		      ↓
			4 4 3 5 2		temp = 1
			  ↑
		3. 작은 값을 찾는 순간의 위치를 idx에 저장하고
		idx+1위치에 임시 저장했던 temp를 덮어 씌워준다.
		      ↓
			1 4 3 5 2		temp = 1
			  ↑
		4. i값을 하나 증가시키며 위의 과정을 반복한다.
		      ↓
			1 3 4 5 2		temp = 2
			        ↑

분할 정복(Divide And Conquer)
	문제를 작은 2개로 분할하고 각각 해결하여 모아서
	원래의 문제를 해결하는 방법

퀵 정렬(Quick Sort)
	분할 정복 방식으로 정렬을 수행하는 방법
	시간 복잡도 : O(NlogN)

	장점 : 알고리즘 중 가장 빠른 평균시간을 갖는다.
	단점 : 구현이 복잡하다.

	기본 로직
		1. 리스트 안에서 가장 오른쪽 요소를 pivot으로 선택
		idx는 가장 왼쪽-1 로 초기화

		2. 리스트에서 가장 오른쪽에서 두번째 요소까지 반복을 돌면서
		pivot값과 비교

		3. 만약 비교대상인 요소의 크기가 pivot보다 작거나 같다면
		idx를 하나 증가시키며 그 위치의 요소와 스왑(앞으로 보내준다.)

		4. 2번의 반복이 끝났다면, 가장 오른쪽 요소를 idx 하나 증가시키며
		그 위치와 스왑(pivot으로 선택됐던 값을 알맞은 위치로 보내준다.)

		5. 방금 스왑된 그 위치를 리턴(pivot값이었던 대상이 위치한 idx 리턴)

		6. 1~5까지의 과정을 거쳤다면 리턴된 그 위치 왼쪽에는 그 요소보다
		작은 값들만 있고, 오른쪽에는 큰값들만 모여있다.
		(리턴된 위치의 값은 정상적으로 정렬된 값이다.)

		7. 정렬된 위치의 값만 제외하고 왼쪽, 오른쪽 리스트들을 분할하여
		quickSort()를 재귀호출 한다.

		8. 분할된 배열의 크기가 1이 되었다면 left<right가 False이므로
		재귀호출을 멈춘다.
















