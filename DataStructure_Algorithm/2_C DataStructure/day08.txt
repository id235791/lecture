개방 주소법(Open Addressing)
	충돌 발생시 다른 주소값에 데이터를 삽입하는 방식
	
	선형탐색법 : 충돌 발생시 주소를 고정폭으로 이동하며 데이터를 삽입하는 방식
		1차 클러스터가 발생할 확률이 높다.

	제곱탐색법 : 이동폭이 제곱수로 늘어난다. 2차 클러스터가 발생한다.
	이중해싱(중복해싱) : 해시함수를 두개 이용하는것, 해싱을 두번 거치는 것

체이닝(Chaining)
	각 해시값의 공간에 연결리스트를 할당하여 데이터 삽입시 충돌이 발생하면
	그 연결리스트에 데이터를 연결하여 삽입하는 방식이다.
	같은 해시값을 갖는 데이터가 계속 추가된다면 한 리스트에만 데이터가
	추가되므로 해싱기법을 쓴 것이 무의미해진다.

--**뛰어난 해싱기법과 체이닝을 적절하게 사용하여 메모리를 관리한다.

정렬 알고리즘
	데이터를 순서대로 나열하기 위한 절차적인 과정, 알고리즘
	선택, 삽입, 버블, 퀵, ..

선택 정렬(Selection Sort)
	최소값 또는 최대값을 선택하여 가장 앞에다가 위치하는 작업을 반복하여
	정렬하는 방법

	장점 : 구현이 쉽다
	단점 : 다른 정렬에 비해 시간이 오래걸린다.

	기본로직
		1. 정렬되지 않은 인덱스의 맨 앞에서부터 이를 포함한
		그 이후의 값들 중에 최소값을 찾아낸다.
			4 [1] 3 5 2
			↑
		2. 최소값을 찾았으면 그 값을 현재 인덱스의 값과 바꾸어준다.
			1 4 3 5 2
		3. 다음 인덱스로 이동하여 위의 과정을 반복한다.
			1 4 3 5 2
			  ↑

버블 정렬(Bubble Sort)
	인접한 두 수를 비교하여 큰 수를 뒤로 보내는 작업을 반복하여
	정렬하는 방법

	장점 : 구현이 쉽고 코드가 직관적이다.
	단점 : 시간이 오래걸린다.

	기본로직
		1. 맨 앞에서부터 바로 뒤에 있는 값과 비교 후
		순서가 거꾸로 되어있다면 둘의 위치를 바꾼다
			4 1 3 5 2	-->	1 4 3 5 2
			↑			↑
		2. 맨 마지막까지 반복해서 바꾸어 주었다면
		가장 마지막에는 최대값이 위치해 있다.
			1 4 3 5 2	-->	1 3 4 5 2
			  ↑			  ↑
		3. 위의 과정을 반복하여 하되 이전보다 한번 덜 바꾸면
		그 다음 최대값이 바로 앞에 위치할 것이다.

삽입정렬(Insertion Sort)
	현재 위치에서 그 앞의 인덱스들 중에 자신이 들어갈 위치를 찾아서
	그 위치에 삽입하여 정렬하는 방법

	장점 : 최선의 경우 빠른 효율성을 갖는다
	단점 : 최악의 경우에는 시간이 오래걸리며 데이터의 상태나 크기에 따라
		성능의 편차가 있다.

	기본로직
		1. 현재 인덱스(i)의 값을 임시 저장한다.(temp)

		2. 그 앞의 값들을 거꾸로 비교하면서 값이 더 큰게 있다면
		바로 뒷자리에 덮어 씌워준다.

		3. 작은 값을 찾는 순간의 idx위치+1 에 임시 저장했던
		temp를 덮어 씌워준다.

		4. i값을 하나 증가시키며 위의 과정을 반복한다.

분할 정복(Divide and Conquer)
	문제를 작은 2개로 분리하고 각각 해결 후 모아서
	원래의 문제를 해결하는 방법

퀵 정렬(Quick Sort)
	분할정복 방식으로 정렬을 수행하는 방법

	장점 : 알고리즘 중 가장 빠른 평균시간을 갖는다.
	단점 : 구현이 복잡하다.

	기본로직
		1. 배열 안에서 가장 오른쪽 요소를 pivot으로 선택
		idx 는 -1로 초기화

		2. 배열에서 가장 오른쪽에서 두번째 요소까지 반복을 돌면서
		pivot값과 비교

		3. 만약 비교대상인 요소의 크기가 pivot보다 작거나 같다면
		idx를 하나 증가시키며 그 위치의 요소와 스왑(앞으로 보내준다)

		4. 2번의 반복이 끝났다면, 가장 오른쪽 요소를 idx 하나 증가시키며
		그 위치와 스왑(pivot으로 선택됐던 값도 알맞은 위치로 보내준다)

		5. 방금 스왑된 그 위치를 리턴(pivot값이었던 대상이 위치한 idx 리턴)

		6. 1~5까지의 과정을 거쳤다면 리턴된 그 위치 왼쪽에는 그 위치의 요소보다
		작은 값들만 있고, 오른쪽에는 큰값들만 모여있다.
		(리턴된 위치의 값은 정상적으로 정렬된 값이다)

		7. 정렬된 위치의 값만 제외하고 왼쪽, 오른쪽 배열들을 분할하여
		quickSort()를 재귀호출 한다.

		8. 분할된 배열의 크기가 1이 되었다면 left<right 가 0이므로
		재귀호출을 멈춘다.











