인터페이스(interface)
	jdk 8버전 이후로는 인터페이스에 default 메소드를 선언할 수 있다.
	따라서 사실상의 다중상속을 지원하게 된다. 인터페이스들 끼리
	메소드 모호성이 발생한다면(같은 이름의 메소드끼리 충돌이 일어난다면)
	상속받은 클래스에서 명시적으로 작성(오버라이딩)해서 모호성을 해결해 주어야 한다.
	상속받은 클래스 내부에서는
		인터페이스명.super.메소드()	< 상속받은 인터페이스의 메소드 호출
		super.메소드()		< 상속받은 클래스의 메소드 호출
	로 상속받은 인터페이스 내부의 메소드를 호출할 수 있고 이는 다중상속을 의미한다.

디자인 패턴
	프로그램 설계의 모습, 방식

어댑터 패턴
	강제성이 강한 interface 대신에 메소드의 틀을 받아오고 싶을 때 사용하는 패턴

팩토리 패턴
	new 생성자() 를 통한 객체 생성 방식의 강한 의존성을 약화시키고자 할 때 사용하는 패턴

싱글톤 패턴
	전체 프로그램에서 특정 타입의 객체를 단 한개만 만들어지게 설계하고 싶을 때 사용하는 패턴

내부 클래스(inner class)
	클래스 내부에 클래스를 선언한 것
	클래스 내부에 클래스를 선언하여 외부 클래스의 필드에 용이하게 접근하기 위해서 사용한다.
	내부 클래스의 필드를 이용하기 위해서는 먼저 외부 클래스의 객체를 만들고 그 객체를 통해
	내부 클래스까지 접근해서 객체화를 해야한다.

	외부클래스명 객체명 = new 외부클래스생성자();
	외부클래스명.내부클래스명 객체명 = 외부클래스객체.new 내부클래스생성자();
	------------------
	import시 축약 가능

	위와 같이 객체화를 하기가 까다롭고 번잡하기 때문에 설계를 다른 방식으로 한다.
	외부 클래스의 필드에서는 자신이랑 같이 올라와 있는 내부 클래스를 바로 객체화 할 수 있다.
	따라서 보통은 특정 메소드의 호출 결과로 내부 객체를 부여받아서 사용하는 방식으로 설계된다.

내부 클래스를 사용하는 이유
	1. 상속처럼 이용
		외부 클래스의 필드를 마치 내 것처럼 접근하여 사용하기 위함
	2. 캡슐화
		외부 클래스의 객체가 없다면 내부 클래스도 존재할 수 없기 때문에
		다른 클래스에서 내부 클래스에 쉽게 접근하지 못하도록 숨기기 위함

내부 클래스 예시
	시나리오 : A버튼을 클릭해야만 B버튼이 생겨나도록 해야 함
	가정 : A버튼 클래스 내부에 B버튼 클래스 선언

	A버튼 생성(A 타입의 객체 생성) -> A 버튼 클릭(A 타입의 객체의 특정 메소드 호출)
	-> B 버튼 생성(특정 메소드 내부에서 B 객체 생성 후 리턴)

익명 클래스(anonymous inner class)
	이름이 없는 클래스

예외 처리
	에러 : 심각한 오류
	예외 : 덜 심각한 오류

try ~ catch ~ finally
	try{
		예외가 발생할 수 있는 문장
		...
	}
	catch(예외클래스명 객체명){
		예외 발생시 실행할 문장
	}
	...
	finally{
		필수로 꼭 해야하는 문장
	}

Exception 클래스
	모든 예외들의 부모 클래스
	모든 예외 객체들은 Exception 타입의 변수에 담길 수 있다.

throws
	예외 떠넘기기
	메소드 선언부 내부에서 발생하는 예외를 무시하고 호출하는 곳으로 떠넘기는 문법
	호출하는 곳에서 예외가 발생하기 때문에 try ~ catch로 그 곳에서 잡아주어야 한다.

	리턴타입 메소드명() throws 예외1, 예외2, ... {
		예외1, 예외2, ... 무시하는 구역
	}

	프로그램의 진행을 방해하지 않음이 확실한 예외가 발생하는데
	매 번마다 try~catch로 묶어서 잡아주기 귀찮을 때
	예외를 일부러 발생시켜서 예외처리를 해당 메소드 호출하는 곳에서 하도록 할 때

Object 클래스
	모든 클래스들의 최상위 클래스

	toString()	: 객체 출력시 나올 문자열을 정의(객체에 대해 설명하는 문자열)
	hashCode()	: 해시값(주소값을 특정 연산을 거치게 한 후 나온 int값) 리턴

	equals()












